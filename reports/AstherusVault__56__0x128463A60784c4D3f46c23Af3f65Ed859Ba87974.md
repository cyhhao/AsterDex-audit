# AstherusVault Audit Report

## 1. Identity & Sources

- **Name**: AstherusVault
- **Address/Chain**: `0x128463A60784c4D3f46c23Af3f65Ed859Ba87974` / BSC (Chain ID: 56)
- **Proxy Type**: ERC1967 Upgradeable Proxy
- **Implementation Address**: `0x31aeb22e148f5b6d0ea5a942c10746caee073378`
- **Source files**:
  - Main contract: `contracts/AstherusVault.sol`
  - Chainlink interface: `@chainlink/contracts/src/v0.8/shared/interfaces/AggregatorV3Interface.sol`
- **Compiler/Settings**: solc v0.8.25+commit.b61c2a91, Optimizer: Yes (200 runs)

## 2. Authority Map (fully resolved)

- **Proxy Admin**: Not directly visible in implementation (requires on-chain verification)
- **DEFAULT_ADMIN_ROLE**: Assigned during initialization to defaultAdmin, TIMELOCK_ADDRESS, and deployer
- **ADMIN_ROLE**: Can manage tokens, signers, validators, and hourly limits
- **PAUSE_ROLE**: Can pause/unpause the contract
- **OPERATE_ROLE**: Can execute batched deposits and withdrawals with validator signatures
- **TIMELOCK_ADDRESS**: Immutable, has DEFAULT_ADMIN_ROLE and controls upgrades
- **Evidence**: Constructor at L110-133, initialize() at L146-155, _authorizeUpgrade() at L165

## 3. Findings

### Finding #1: Missing Chainlink Oracle Timestamp Validation
- **ID**: ASTH-001
- **Title**: Stale Price Data Vulnerability in _amountUsd Function
- **Severity**: HIGH
- **Impact**: Contract may use stale/outdated price data for withdrawal limit calculations, potentially allowing excessive withdrawals during price manipulation or oracle failures
- **Likelihood**: Medium - Chainlink oracles can experience delays or outages

#### Affected Code
File: `contracts/AstherusVault.sol#L472-L481`
```solidity
function _amountUsd(address currency, uint256 amount) private view returns (uint256) {
    Token memory token = supportToken[currency];
    uint256 price = token.price;
    if (!token.fixedPrice) {
        AggregatorV3Interface oracle = AggregatorV3Interface(token.priceFeed);
        (, int256 price_,,,) = oracle.latestRoundData();  // Missing updatedAt timestamp check
        price = uint256(price_);
    }
    return price * amount * (10 ** USD_DECIMALS) / (10 ** (token.priceDecimals + token.currencyDecimals));
}
```

#### Technical Details

The `_amountUsd` function calls `oracle.latestRoundData()` which returns 5 values:
1. `roundId` - The round ID
2. `answer` - The price value (used as `price_`)
3. `startedAt` - Timestamp when the round started
4. `updatedAt` - **Timestamp when the price was last updated (IGNORED)**
5. `answeredInRound` - The round ID in which the answer was computed

**Critical Issue**: The function only uses the price value (`answer`) but ignores the `updatedAt` timestamp. This means:

1. **Stale Data Risk**: If the oracle stops updating (due to network issues, oracle node failures, or attacks), the contract will continue using the last known price indefinitely
2. **Price Manipulation**: During extreme market volatility or flash crashes, old prices could be exploited
3. **Withdrawal Limit Bypass**: Attackers could exploit stale prices to withdraw more than intended when:
   - Real price has dropped but oracle shows old higher price
   - Allows withdrawing more tokens while staying under USD limit

#### Exploit Scenario

1. Oracle stops updating at time T with BNB price at $600
2. Real BNB price drops to $300 at time T+1 hour
3. Attacker can withdraw 2x the intended BNB amount because contract still uses $600 price
4. Withdrawal stays under hourly USD limit based on stale price

#### Evidence

- Function is called in critical withdrawal paths:
  - `withdraw()` at L432 for withdrawal limit checks
  - `checkLimit()` at L512 for hourly limit enforcement
- No timestamp validation exists anywhere in the contract
- Chainlink best practices recommend checking `updatedAt` timestamp

#### Remediation

```solidity
function _amountUsd(address currency, uint256 amount) private view returns (uint256) {
    Token memory token = supportToken[currency];
    uint256 price = token.price;
    if (!token.fixedPrice) {
        AggregatorV3Interface oracle = AggregatorV3Interface(token.priceFeed);
        (uint80 roundId, int256 price_, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound) = oracle.latestRoundData();

        // Add timestamp validation
        require(updatedAt > 0, "Invalid oracle response");
        require(block.timestamp - updatedAt <= 3600, "Oracle data is stale"); // 1 hour max staleness
        require(price_ > 0, "Invalid price");
        require(answeredInRound >= roundId, "Stale price round");

        price = uint256(price_);
    }
    return price * amount * (10 ** USD_DECIMALS) / (10 ** (token.priceDecimals + token.currencyDecimals));
}
```

**Status**: Open

### Finding #2: Missing Price Validation
- **ID**: ASTH-002
- **Title**: No Validation for Negative or Zero Prices
- **Severity**: MEDIUM
- **Impact**: Contract could malfunction if oracle returns invalid price (0 or negative)
- **Likelihood**: Low - Chainlink oracles are generally reliable but edge cases exist

#### Affected Code
File: `contracts/AstherusVault.sol#L477-L478`

```solidity
(, int256 price_,,,) = oracle.latestRoundData();
price = uint256(price_); // Direct cast without validation
```

#### Technical Details

The code directly casts `int256 price_` to `uint256` without checking:
- If price is negative (would underflow to huge number)
- If price is zero (would cause division issues or allow free withdrawals)

#### Remediation

Add price validation as shown in Finding #1's remediation.

**Status**: Open

### Finding #3: Single Point of Failure in Signer
- **ID**: ASTH-003
- **Title**: Single Signer for Legacy Withdrawals
- **Severity**: MEDIUM
- **Impact**: If signer key is compromised, attacker can authorize arbitrary withdrawals
- **Likelihood**: Low-Medium depending on key management practices

#### Affected Code
File: `contracts/AstherusVault.sol#L422-L423`

```solidity
function withdraw(bytes calldata message, bytes calldata signature) external whenNotPaused {
    require(signer.isValidSignatureNow(MessageHashUtils.toEthSignedMessageHash(keccak256(message)), signature), "only accept truthHolder signed message");
```

#### Technical Details

The legacy withdrawal function relies on a single signer address. While there's a newer multi-validator withdrawal mechanism, the single-signer method is still active and poses risks.

#### Remediation

Consider deprecating the single-signer withdrawal in favor of the multi-validator approach, or implement a multi-sig requirement for the legacy path.

**Status**: Open


## 4. Invariants & Tests

Key invariants that should be maintained:
1. **Withdrawal Limit**: `withdrawPerHours[hour] <= hourlyLimit`
2. **Oracle Freshness**: Price data should be updated within acceptable staleness period
3. **Withdrawal Uniqueness**: Each withdrawal ID should only be processed once
4. **Validator Threshold**: Validator signatures should meet 2/3 power threshold
5. **Price Validity**: Prices should always be > 0